# Mannheim Urban Heat Explorer - Konkrete Implementierung
import pandas as pd
import numpy as np
import requests
import json
from datetime import datetime, timedelta

# Mannheim-spezifische Konfiguration
MANNHEIM_CONFIG = {
    'city': 'Mannheim',
    'center_coords': [49.4875, 8.4660],  # Wasserturm
    'bbox': [49.4200, 8.3800, 49.5400, 8.5500],  # [south, west, north, east]
    'districts': [
        'Innenstadt/Jungbusch', 'Neckarstadt-Ost', 'Neckarstadt-West',
        'Schwetzingerstadt/Oststadt', 'Lindenhof', 'Neckarau',
        'K√§fertal', 'Waldhof', 'Sandhofen', 'Rheinau'
    ],
    'key_areas': {
        'industrial': 'Industriehafen, BASF-N√§he',
        'commercial': 'Planken, Paradeplatz',
        'residential': 'Oststadt, Lindenhof',
        'green': 'Luisenpark, Herzogenriedpark'
    }
}

class MannheimDataCollector:
    """Spezifischer Data Collector f√ºr Mannheim"""
    
    def __init__(self):
        self.config = MANNHEIM_CONFIG
        self.apis = {
            'openweather': 'https://api.openweathermap.org/data/2.5/',
            'overpass': 'https://overpass-api.de/api/interpreter',
            'dwd': 'https://opendata.dwd.de/climate_environment/CDC/'
        }
    
    def get_mannheim_overpass_query(self, feature_type):
        """Erstellt Overpass-Query f√ºr Mannheim"""
        bbox = self.config['bbox']
        
        queries = {
            'parking': f"""
            [out:json][timeout:25];
            (
              way["amenity"="parking"]({bbox[0]},{bbox[1]},{bbox[2]},{bbox[3]});
              way["highway"="residential"]["parking:lane"~"parallel|diagonal"]({bbox[0]},{bbox[1]},{bbox[2]},{bbox[3]});
              relation["amenity"="parking"]({bbox[0]},{bbox[1]},{bbox[2]},{bbox[3]});
            );
            out geom;
            """,
            
            'green_spaces': f"""
            [out:json][timeout:25];
            (
              way["leisure"="park"]({bbox[0]},{bbox[1]},{bbox[2]},{bbox[3]});
              way["landuse"="forest"]({bbox[0]},{bbox[1]},{bbox[2]},{bbox[3]});
              way["natural"="wood"]({bbox[0]},{bbox[1]},{bbox[2]},{bbox[3]});
              relation["leisure"="park"]({bbox[0]},{bbox[1]},{bbox[2]},{bbox[3]});
            );
            out geom;
            """,
            
            'buildings': f"""
            [out:json][timeout:25];
            (
              way["building"]({bbox[0]},{bbox[1]},{bbox[2]},{bbox[3]});
              relation["building"]({bbox[0]},{bbox[1]},{bbox[2]},{bbox[3]});
            );
            out geom;
            """,
            
            'streets': f"""
            [out:json][timeout:25];
            (
              way["highway"~"primary|secondary|tertiary|residential"]({bbox[0]},{bbox[1]},{bbox[2]},{bbox[3]});
            );
            out geom;
            """
        }
        
        return queries.get(feature_type, "")
    
    def simulate_mannheim_temperature_grid(self, grid_size=50):
        """Simuliert Temperaturdaten f√ºr Mannheim basierend auf realen Gegebenheiten"""
        np.random.seed(42)
        
        # Mannheim-spezifische Temperaturmuster
        data = []
        bbox = self.config['bbox']
        
        lat_range = np.linspace(bbox[0], bbox[2], grid_size)
        lon_range = np.linspace(bbox[1], bbox[3], grid_size)
        
        for lat in lat_range:
            for lon in lon_range:
                # Distanz zu verschiedenen Landmarks
                center_dist = np.sqrt((lat - 49.4875)**2 + (lon - 8.4660)**2)
                rhein_dist = abs(lon - 8.4400)  # N√§he zum Rhein
                neckar_dist = abs(lat - 49.4900)  # N√§he zum Neckar
                
                # Basis-Temperatur je nach Lage
                base_temp = 24.0
                
                # Innenstadt-Effekt (h√∂here Temperaturen)
                if center_dist < 0.02:  # Zentrum
                    base_temp += 3.0
                    area_type = 'commercial'
                    sealed_ratio = 0.85
                    vegetation = 0.10
                    
                # Industriegebiet (BASF-N√§he, Hafen)
                elif lat < 49.47 and lon > 8.50:
                    base_temp += 4.0
                    area_type = 'industrial'
                    sealed_ratio = 0.90
                    vegetation = 0.05
                    
                # Rhein-N√§he (k√ºhlender Effekt)
                elif rhein_dist < 0.01:
                    base_temp -= 2.0
                    area_type = 'waterfront'
                    sealed_ratio = 0.60
                    vegetation = 0.30
                    
                # Gr√ºnfl√§chen (Luisenpark, etc.)
                elif (lat > 49.48 and lat < 49.49 and lon > 8.46 and lon < 8.48):
                    base_temp -= 3.0
                    area_type = 'park'
                    sealed_ratio = 0.20
                    vegetation = 0.80
                    
                # Wohngebiete
                else:
                    base_temp += np.random.uniform(-1, 1)
                    area_type = 'residential'
                    sealed_ratio = np.random.uniform(0.50, 0.75)
                    vegetation = np.random.uniform(0.20, 0.40)
                
                # Finale Temperatur mit Rauschen
                temperature = base_temp + np.random.normal(0, 1.5)
                
                data.append({
                    'lat': lat,
                    'lon': lon,
                    'temperature': temperature,
                    'area_type': area_type,
                    'sealed_surface_ratio': sealed_ratio,
                    'vegetation_ratio': vegetation,
                    'parking_density': np.random.uniform(0.1, 0.6),
                    'building_density': np.random.uniform(0.3, 0.8),
                    'distance_to_center': center_dist,
                    'distance_to_water': min(rhein_dist, neckar_dist)
                })
        
        return pd.DataFrame(data)

# Mannheim-spezifische Analyse
class MannheimHeatAnalyzer:
    """Heat Island Analyse speziell f√ºr Mannheim"""
    
    def __init__(self):
        self.mannheim_factors = {
            'sealed_surface_ratio': 0.35,
            'vegetation_ratio': -0.45,
            'parking_density': 0.25,
            'building_density': 0.20,
            'distance_to_water': 0.15,  # Rhein/Neckar K√ºhlungseffekt
            'industrial_proximity': 0.30  # BASF/Hafen W√§rmeeffekt
        }
    
    def identify_mannheim_hotspots(self, df):
        """Identifiziert Mannheim-spezifische Hotspots"""
        # Heat Index berechnen
        df['heat_index'] = 0
        for factor, weight in self.mannheim_factors.items():
            if factor in df.columns:
                if factor == 'distance_to_water':
                    # Umkehrung: gr√∂√üere Distanz = h√∂herer Heat Index
                    df['heat_index'] += df[factor] * weight * 100
                else:
                    df['heat_index'] += df[factor] * weight * 100
        
        # Hotspots definieren (obere 20%)
        hotspot_threshold = df['temperature'].quantile(0.8)
        df['is_hotspot'] = df['temperature'] > hotspot_threshold
        
        # Mannheim-spezifische Kategorisierung
        df['heat_category'] = pd.cut(df['temperature'], 
                                   bins=[0, 22, 24, 26, 100],
                                   labels=['Cool', 'Moderate', 'Warm', 'Hot'])
        
        return df

# Demo f√ºr Mannheim
print("üè≠ MANNHEIM URBAN HEAT EXPLORER")
print("=" * 50)

# Daten sammeln
collector = MannheimDataCollector()
mannheim_data = collector.simulate_mannheim_temperature_grid(30)

print(f"üìä Datensatz erstellt: {len(mannheim_data)} Messpunkte")
print(f"üå°Ô∏è  Temperaturbereich: {mannheim_data['temperature'].min():.1f}¬∞C - {mannheim_data['temperature'].max():.1f}¬∞C")

# Analyse durchf√ºhren
analyzer = MannheimHeatAnalyzer()
mannheim_analyzed = analyzer.identify_mannheim_hotspots(mannheim_data)

# Ergebnisse nach Stadtgebieten
print(f"\nüèòÔ∏è  ANALYSE NACH GEBIETSTYPEN:")
area_stats = mannheim_analyzed.groupby('area_type').agg({
    'temperature': ['mean', 'max', 'count'],
    'sealed_surface_ratio': 'mean',
    'vegetation_ratio': 'mean'
}).round(2)

for area_type in mannheim_analyzed['area_type'].unique():
    subset = mannheim_analyzed[mannheim_analyzed['area_type'] == area_type]
    avg_temp = subset['temperature'].mean()
    hotspot_count = subset['is_hotspot'].sum()
    total_count = len(subset)
    
    print(f"  {area_type.upper()}: √ò {avg_temp:.1f}¬∞C, {hotspot_count}/{total_count} Hotspots")

# Hotspot-Analyse
hotspots = mannheim_analyzed[mannheim_analyzed['is_hotspot']]
print(f"\nüî• HEAT ISLAND HOTSPOTS ({len(hotspots)} Gebiete):")
print(f"   Durchschnittstemperatur: {hotspots['temperature'].mean():.1f}¬∞C")
print(f"   Versiegelungsgrad: {hotspots['sealed_surface_ratio'].mean():.1%}")
print(f"   Vegetationsanteil: {hotspots['vegetation_ratio'].mean():.1%}")

# K√ºhlste Gebiete
cool_spots = mannheim_analyzed[mannheim_analyzed['heat_category'] == 'Cool']
print(f"\n‚ùÑÔ∏è  K√úHLSTE GEBIETE ({len(cool_spots)} Gebiete):")
print(f"   Durchschnittstemperatur: {cool_spots['temperature'].mean():.1f}¬∞C")
print(f"   Haupts√§chlich: {cool_spots['area_type'].mode().iloc[0]}")

print(f"\nüìç MANNHEIM-SPEZIFISCHE ERKENNTNISSE:")
print(f"   ‚Ä¢ Industriegebiet (BASF-N√§he): H√∂chste Temperaturen")
print(f"   ‚Ä¢ Rhein/Neckar-N√§he: K√ºhlungseffekt erkennbar")
print(f"   ‚Ä¢ Luisenpark-Bereich: Deutliche Temperaturreduktion")
print(f"   ‚Ä¢ Innenstadt: Typischer Urban Heat Island Effekt")

# N√§chste Schritte f√ºr Mannheim
print(f"\nüéØ N√ÑCHSTE SCHRITTE F√úR MANNHEIM:")
print("   1. Echte Wetterstationen-Daten von DWD integrieren")
print("   2. OSM-Daten f√ºr Mannheim abrufen")
print("   3. Satellitendaten (Landsat/Sentinel) f√ºr LST")
print("   4. Verkehrsdaten der Stadt Mannheim")
print("   5. Interaktive Karte mit Folium erstellen")
